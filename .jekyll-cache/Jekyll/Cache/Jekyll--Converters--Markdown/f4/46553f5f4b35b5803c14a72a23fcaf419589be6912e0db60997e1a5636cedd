I"-<h2 id="-selection-sort선택-정렬">🥕 Selection Sort(선택 정렬)</h2>

<p>선택 정렬은 배열에서 가장 작은 값을 선택하고 그 값을 배열의 맨 앞으로 이동시키는 과정을 반복하여 정렬을 수행하는 방법이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">min_idx</span> <span class="o">=</span> <span class="n">idx</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">num_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num_list</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]:</span>
            <span class="n">min_idx</span> <span class="o">=</span> <span class="n">j</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">min_idx</span><span class="p">:</span>
        <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">num_list</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_list</span><span class="p">[</span><span class="n">min_idx</span><span class="p">],</span> <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

<span class="k">print</span><span class="p">(</span><span class="n">num_list</span><span class="p">)</span>
</code></pre></div></div>

<p>선택 정렬은 가장 작은 값을 선택해 배열의 앞쪽부터 정렬해가는 방식을 수행한다. 파이썬으로 구현한다면 위와 같이 구현할 수 있으며, 배열의 첫번째 요소부터 시작해 가장 작은 값을 찾아서 배열의 맨 앞으로 보낸식의 코드이다. for문을 이용하여 배열의 인덱스를 하나씩 순회하며 현재 인덱스부터 배열의 끝까지 중 가장 작은 값을 찾아서 현재 위치로 이동시키는 과정을 반복한다.  <br />
<br />
버블정렬과 선택 정렬과의 차이는 버블 정렬은 첫번째 요소와 두번째 요소를 비교하여 큰값을 뒤로 보내는 형식으로 구현되어 있는 반면에 선택 정렬은 배열에서 가장 작은 최솟값을 찾아 첫번째 요소와 교환하는 식으로 구현되어 있다.</p>

<h4 id="장점">장점</h4>
<ul>
  <li>구현이 간단하고 이해하기 쉽다</li>
  <li>제자리 정렬로 추가 메모리가 필요하지 않음</li>
  <li>데이터 이동 횟수가 미리 결정되어 있어 안정성이 높음</li>
</ul>

<h4 id="단점">단점</h4>
<ul>
  <li>평균적인 시간복잡도가 $O(n^2)$이므로 데이터가 많을수록 느려짐</li>
  <li>입력 데이터의 초기 순서에 따라 성능이 크게 좌우됨</li>
  <li>비교적 큰 데이터 셋에 대해 효율적이지 않음</li>
</ul>

<p><br /></p>
<blockquote>
  <p>Insertion Sort(삽입 정렬)</p>
</blockquote>

<p>삽입 정렬은 데이터 셋을 순회하면서 정렬이 필요한 요소를 뽑아내어 이를 다시 적당한 곳으로 삽입하는 방식이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="k">for</span> <span class="n">list_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">)):</span>
    <span class="n">element</span> <span class="o">=</span> <span class="n">num_list</span><span class="p">[</span><span class="n">list_idx</span><span class="p">]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">list_idx</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="k">while</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">element</span><span class="p">:</span>
        <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> 
        <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span> 
</code></pre></div></div>

<p>리스트의 두번째 요소부터 시작해서 그 이전의 요소들을 비교하는 파이썬 코드이며, 이전에 있던 정렬 알고리즘들과 다르게 삽입정렬 while문이 들어간다. (물론 while문 없어도 구현은 가능)</p>

<p>하지만 while문을 사용하는 이유는 현재 위치에서 그 이전의 요소들을 전부 하나씩 비교하여 자신이 들어갈 위치를 찾아 삽입하기 때문에 대부분의 삽입 정렬에는 while문을 사용한다.</p>

<h4 id="장점-1">장점</h4>
<ul>
  <li>구현이 간단하고 이해하기 쉬움</li>
  <li>작은 데이터 세트에 대해 효율적인 알고리즘이며 데이터 세트가 이미 정렬되어 있을 경우에는 더욱 빠름</li>
  <li>Stable Sort이기 때문에 데이터가 동일한 값을 가지는 경우에도 순서가 바뀌지 않음</li>
</ul>

<h4 id="단점-1">단점</h4>
<ul>
  <li>데이터 세트의 길이가 길어질수록 비효율적임</li>
  <li>최악의 경우 데이터의 정렬이 역순으로 되어 있는 경우 모든 요소를 비교해야 하므로 $O(n^2)$의 시간복잡도를 가짐</li>
  <li>제자리 정렬 아니기 때문에 추가적인 메모리 공간이 필요함s</li>
</ul>

<p><br /></p>
<blockquote>
  <p>Shell Sort (쉘 정렬)</p>
</blockquote>

<p>쉘 정렬은 삽입 정렬을 보완하여 만들어진 정렬 알고리즘이다. 배열을 일정한 간격(Gap)으로 분할한 후, 각 부분 리스트를 삽입 정렬을 이용하여 정렬하고 다시 간격을 줄여가면서 정렬를 반복한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">shell_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">gap</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">gap</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="n">gap</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Sedgewick gap sequence
</span>
    <span class="k">while</span> <span class="n">gap</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gap</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">gap</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">gap</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span><span class="p">:</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">gap</span><span class="p">]</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="n">gap</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
        <span class="n">gap</span> <span class="o">//=</span> <span class="mi">3</span>
    <span class="k">return</span> <span class="n">arr</span> 
</code></pre></div></div>

<p>간격이 1이 될때까지 while 루프를 반복하면서 일정한 가격만큼 떨어져 있는 요소끼리 비교하여 삽입 정렬을 수행한다. gap을 나누는 작업으로 간격을 점점 줄여나가며, 최종적으로 전체 배열이 정렬된다.</p>

<h4 id="장점-2">장점</h4>
<ul>
  <li>삽입정렬보다 속도가 빠르다.</li>
  <li>안정 정렬(Stable Sort)이기 때문에 동일한 값에 대해 원래의 상대적인 순서로 유지</li>
  <li>간격을 다양하게 선택하여 다양한 성능을 얻을 수 있음</li>
</ul>

<h4 id="단점-2">단점</h4>
<ul>
  <li>간격 선택에 따라 성능이 크게 달라지기 때문에 적절한 간격을 선택하지 않는다면 성능이 급격하게 저하될 수 있음</li>
  <li>안정성을 보장하기 위해 불필요한 비교 연산이 필요할 수 있음</li>
  <li>구현하기 상대적으로 복잡함</li>
</ul>

:ET