I"F<p>정렬 알고리즘은 N개의 숫자가 주어졌을 때, 사용자가 지정한 기준에 맞게 정렬하는 알고리즘을 말한다.</p>

<h2 id="잠깐-집고-넘어가기">🤚🏻 잠깐, 집고 넘어가기</h2>

<p>정렬 알고리즘에 대해 설명하기 전에 아래 개념을 알아두자. <br />
Stable는 같은 값을 가지는 요소들이 정렬된 순서가 유지되는 것을 말하며, In Place는 입력 배열 외 추가적인 배열을 사용하지 않는 것을 말한다. Not Stable은 반대로 같은 값을 가지는 요소들의 정렬 순서가 유지되지 않는 것을 말하고, Not In Place는 추가적인 배열을 사용하는 것을 말한다. 정리하면 아래와 같다.</p>

<ul>
  <li>stable : 중복된 키 값이 있을 때, 해당 값들이 처음 나타난 순서대로 정렬됨</li>
  <li>not stable : 중복된 키 값이 있을 때, 해당 값들의 상대적인 순서가 보장되지 않음</li>
  <li>in place : 추가적인 저장 공간을 상수 시간 내에 고정된 양만 사용함</li>
  <li>not in place : 추가적인 저장 공간을 원소들의 갯수에 비례하여 사용함</li>
</ul>

<p><code class="highlighter-rouge">1. Stable, In Place</code></p>
<ul>
  <li>삽입 정렬, 버블 정렬, 머지 정렬<br />
<code class="highlighter-rouge">머지 정렬은 일반적으로는 Stabel, 추가적인 배열 사용으로 Not in Place가 될 수 있음</code></li>
</ul>

<p><code class="highlighter-rouge">2. Not Stable, In Place</code></p>
<ul>
  <li>선택 정렬 , 퀵 정렬, 힙 정렬 <br />
<code class="highlighter-rouge">퀵 정렬은 Pivot 선택 방법에 따라 Stable할수도 있고, 추가적인 배열 사용으로 Not in Place가 될 수 있음</code></li>
</ul>

<p><code class="highlighter-rouge">3. Stable, Not In Place</code></p>
<ul>
  <li>계수 정렬, 기수 정렬</li>
</ul>

<p><code class="highlighter-rouge">4. Not Stable, Not In Place</code></p>
<ul>
  <li>쉘 정렬</li>
</ul>

<p>또한 정렬 알고리즘은 실행 방법과 정렬 장소에 따라 아래와 같이 분류할 수 있다.</p>

<h4 id="1-실행-방법에-따른-분류">1. 실행 방법에 따른 분류</h4>

<p>정렬 알고리즘 실행 방법에 따라 비교식 정렬(Comparative Sort), 분산식 정렬(Distribute Sort)로 분류할 수 있다.</p>

<ul>
  <li>Comparative Sort(비교식 정렬) : 비교식 정렬은 비교하고자하는 각 키값들을 한번에 두개씩 비교하는 교환 방식을 말한다. 대부분의 정렬 알고리즘이 비교식 정렬에 해당된다.
    <ul>
      <li>버블 정렬, 선택 정렬, 삽입 정렬, 퀵 정렬, 병합 정렬, 힙 정렬 등</li>
    </ul>
  </li>
  <li>Distribute Sort(분산식 정렬) : 분산식 정렬은 키값을 기준으로 하여 자료를 여러 개의 부분 집합으로 분해하고, 분해한 집합들간의 비교, 교환, 이동 등의 작업을 통해 정렬하는 방식이다. 대부분의 비교식 정렬보다는 더 빠른 속도를 보인다는 장점이 있다.
    <ul>
      <li>기수 정렬, 버킷 정렬, 카운팅 정렬 등</li>
    </ul>
  </li>
</ul>

<h4 id="2-정렬-장소에-따른-분류">2. 정렬 장소에 따른 분류</h4>

<p>정렬 알고리즘 장소에 따라 내부 정렬(Internal Sort), 외부 정렬(External Sort)로 분류할 수 있다.</p>

<ul>
  <li>Internal Sort(내부 정렬) : 내부 정렬은 정렬할 자료를 메인 메모리에 올려서 정렬하는 방식으로, 속도가 빠르지만 자료의 양이 메모리의 용량에 따라 제한된다는 단점이 있다.
    <ul>
      <li>버블 정렬, 선택정렬, 삽입 정렬, 퀵 정렬, 병합 정렬, 힙 정렬 등</li>
    </ul>
  </li>
  <li>External Sort(외부 정렬) : 외부 정렬은 정렬할 자료를 보조 기억 장치에서 정렬하는 방식이다. 내부 정렬보다는 속도는 떨어지지만 대용량의 자료에 대한 정렬이 가능하다는 장점이 있다.
    <ul>
      <li>병합 정렬 등</li>
    </ul>
  </li>
</ul>

<h2 id="-정렬-알고리즘">🥕 정렬 알고리즘</h2>

<p>정렬 알고리즘의 종류는 여러가지가 있지만 이번 포스팅에서는 버블 정렬, 선택 정렬, 삽입 정렬, 쉘 정렬, 퀵 정렬, 힙 정렬, 머지 정렬, 리덕스 정렬에 대한 이해와 파이썬 구현을 하려고 한다. <br />
<br /></p>
<blockquote>
  <p>Bubble Sort(버블 정렬)</p>
</blockquote>

<p>버블 정렬은 인접한 두 요소의 크기를 비교하여 서로 교환하는 정렬 알고리즘이다. 버블 정렬은 두 개의 for루프를 사용하여 구현할 수 있으며 첫 번째 for 루프는 정렬할 리스트 길이 만큼 반복하고, 두 번째 for 루프는 인접한 두 요소를 비교하여 정렬을 수행한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

<span class="k">for</span> <span class="n">lens</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
</code></pre></div></div>

<p>파이썬으로 구현하면 이렇게 구현할 수 있다. 이 형태는 버블 정렬의 기본적인 형태이고 많은 곳에서도 볼 수 있는 코드이지만, 이렇게 코드를 작성하게 된다면 정렬이 완료된 이후에는 더 이상 비교하지 않아도 되는데도 불구하고 계속 비교를 수행하게 된다. 그래서 아래와 같이 코드를 수정하면 조금 더 효율성을 높일 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">)):</span>
    <span class="n">is_sorted</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">num_list</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">num_list</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">num_list</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_list</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">num_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">is_sorted</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">is_sorted</span><span class="p">:</span>
        <span class="k">break</span>
</code></pre></div></div>

<p>이렇게 수정하게 된다면, 이전과 같이 정렬이 완료되었는지 여부를 확인하기 때문에 불필요한 순회를 종류할 수 있다.</p>

<h4 id="장점">장점</h4>
<ul>
  <li>구현하기 쉽고 이해하기 쉬움</li>
  <li>정렬할 데이터가 거의 정렬된 경우에는 다른 정렬 알고리즘보다 빠름</li>
  <li>추가적인 메모리 공간이 필요하지 않음</li>
</ul>

<h4 id="단점">단점</h4>
<ul>
  <li>시간 복잡도가 $O(n^2)$으로 상당히 느리며, 데이터가 많아질수록 더욱 느려짐</li>
  <li>최악의 경우에는 모든 원소를 비교해야 하므로, 정렬할 데이터의 크기에 비례하여 연산 횟수가 매우 많아짐</li>
  <li>Stabel Sort가 아니므로 같은 값에 대해 상대적인 순서가 보장되지 않음</li>
  <li>다른 정렬 알고리즘에 비해 정렬 속도가 느리고 효율적이지 않음</li>
</ul>

<p><br /></p>
<blockquote>
  <p>Selection Sort(선택 정렬)</p>
</blockquote>

<p>선택 정렬은 배열에서 가장 작은 값을 선택하고 그 값을 배열의 맨 앞으로 이동시키는 과정을 반복하여 정렬을 수행하는 방법이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">min_idx</span> <span class="o">=</span> <span class="n">idx</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">num_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num_list</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]:</span>
            <span class="n">min_idx</span> <span class="o">=</span> <span class="n">j</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">min_idx</span><span class="p">:</span>
        <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">num_list</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_list</span><span class="p">[</span><span class="n">min_idx</span><span class="p">],</span> <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

<span class="k">print</span><span class="p">(</span><span class="n">num_list</span><span class="p">)</span>
</code></pre></div></div>

<p>선택 정렬은 가장 작은 값을 선택해 배열의 앞쪽부터 정렬해가는 방식을 수행한다. 파이썬으로 구현한다면 위와 같이 구현할 수 있으며, 배열의 첫번째 요소부터 시작해 가장 작은 값을 찾아서 배열의 맨 앞으로 보낸식의 코드이다. for문을 이용하여 배열의 인덱스를 하나씩 순회하며 현재 인덱스부터 배열의 끝까지 중 가장 작은 값을 찾아서 현재 위치로 이동시키는 과정을 반복한다.  <br />
<br />
버블정렬과 선택 정렬과의 차이는 버블 정렬은 첫번째 요소와 두번째 요소를 비교하여 큰값을 뒤로 보내는 형식으로 구현되어 있는 반면에 선택 정렬은 배열에서 가장 작은 최솟값을 찾아 첫번째 요소와 교환하는 식으로 구현되어 있다.</p>

<h4 id="장점-1">장점</h4>
<ul>
  <li>구현이 간단하고 이해하기 쉽다</li>
  <li>제자리 정렬로 추가 메모리가 필요하지 않음</li>
  <li>데이터 이동 횟수가 미리 결정되어 있어 안정성이 높음</li>
</ul>

<h4 id="단점-1">단점</h4>
<ul>
  <li>평</li>
</ul>

<p><br /></p>
<blockquote>
  <p>Insertion Sort(삽입 정렬)</p>
</blockquote>

<p>삽입 정렬은 데이터 셋을 순회하면서 정렬이 필요한 요소를 뽑아내어 이를 다시 적당한 곳으로 삽입하는 방식이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="k">for</span> <span class="n">list_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_list</span><span class="p">)):</span>
    <span class="n">element</span> <span class="o">=</span> <span class="n">num_list</span><span class="p">[</span><span class="n">list_idx</span><span class="p">]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">list_idx</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="k">while</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">element</span><span class="p">:</span>
        <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> 
        <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">num_list</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span> 
</code></pre></div></div>

<p>리스트의 두번째 요소부터 시작해서 그 이전의 요소들을 비교하는 파이썬 코드이며, 이전에 있던 정렬 알고리즘들과 다르게 삽입정렬 while문이 들어간다. (물론 while문 없어도 구현은 가능)</p>

<p>하지만 while문을 사용하는 이유는 현재 위치에서 그 이전의 요소들을 전부 하나씩 비교하여 자신이 들어갈 위치를 찾아 삽입하기 때문에 대부분의 삽입 정렬에는 while문을 사용한다.</p>

<p><br /></p>
<blockquote>
  <p>Shell Sort (쉘 정렬)</p>
</blockquote>

<p>쉘 정렬은 삽입 정렬을 보완하여 만들어진 정렬 알고리즘이다. 배열을 일정한 간격(Gap)으로 분할한 후, 각 부분 리스트를 삽입 정렬을 이용하여 정렬하고 다시 간격을 줄여가면서 정렬를 반복한다.</p>

:ET